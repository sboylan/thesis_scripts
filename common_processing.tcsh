#!/bin/tcsh -xef

echo "auto-generated by afni_proc.py, Tue Nov 29 09:27:30 2022"
echo "(version 7.12, April 14, 2020)"
echo "execution started: `date`"

# to execute via tcsh: 
#   tcsh -xef XXX.tcsh |& tee output.XXX
# to execute via bash: 
#   tcsh -xef XXX.tcsh 2>&1 | tee output.XXX

set dataFolder =  XXX/quantitativ_fMRI/data

# assign output directory name
set subjects =  ('Sujet2' 'Sujet3' 'Sujet4' 'Sujet5' 'Sujet6' 'Sujet7' 'Sujet8' 'Sujet9' 'Sujet10' 'Sujet11' 'Sujet13' )
set subjects =  ('Sujet7' 'Sujet8' 'Sujet9' 'Sujet10' 'Sujet11' 'Sujet13' )
set output_directory = common_processing
# ===========================  block: setup ============================
# script setup

# take note of the AFNI version
afni -ver

# check that the current AFNI version is recent enough
afni_history -check_date 27 Jun 2019
if ( $status ) then
    echo "** this script requires newer AFNI binaries (than 27 Jun 2019)"
    echo "   (consider: @update.afni.binaries -defaults)"
    exit
endif

cd $dataFolder
set home = $PWD
set template = XXX/abin/MNI152_T1_2009c+tlrc
# ============= SUBJECT loop =====================
# the user may specify a single subject to run with
foreach subj ( $subjects )
    set output_dir = $dataFolder/$subj/Analysis/$output_directory

    cd $subj
    # verify that the results directory does not yet exist
    if ( -d $output_dir ) then
        echo output dir "$output_dir" already exists
        exit
    endif

    if (! -d $output_dir/stimuli) mkdir -p $output_dir/stimuli

    # set list of runs
    if ( -d ./tapping ) then 
        set runs = (`count -digits 2 1 3`)
        set runsMotReg = (`count -digits 2 2 3`)
    else
        set runs = (`count -digits 2 1 2`)
        set runsMotReg = (`count -digits 2 2 2`)
    endif


    # note 4 echoes and registration echo index
    set echo_list = (`count -digits 2 1 4`)
    set echo_times = ( 9.1 25.0 39.6 54.3 )
    set fave_echo = '01'

    # create results and stimuli directories

    # copy anatomy to results dir
    3dcopy anat/anat.nii $output_dir/tmpanat

    # copying respiratory data
    if ( -f "gating/respData_r01.1D" ) then
        cp gating/respData_r01.1D $output_dir/stimuli/
    endif

    if ( -f "gating/respData_r02.1D" ) then
        cp gating/respData_r02.1D $output_dir/stimuli/
    endif

    if ( -f "gating/respData_r03.1D" ) then
        cp gating/respData_r03.1D $output_dir/stimuli/
    endif
    # ============================ auto block: tcat ============================
    # apply 3dTcat to copy input dsets to results dir,
    # while removing the first 10 TRs
    set FILE = 'breathhold/deobECHO1.nii'
    if ( ! -f "$FILE" ) then
        3dWarp -deoblique -prefix breathhold/deobECHO1.nii breathhold/ECHO1.nii
        3dWarp -deoblique -prefix breathhold/deobECHO2.nii breathhold/ECHO2.nii
        3dWarp -deoblique -prefix breathhold/deobECHO3.nii breathhold/ECHO3.nii
        3dWarp -deoblique -prefix breathhold/deobECHO4.nii breathhold/ECHO4.nii
        3dWarp -deoblique -prefix hick/deobECHO1.nii hick/ECHO1.nii
        3dWarp -deoblique -prefix hick/deobECHO2.nii hick/ECHO2.nii
        3dWarp -deoblique -prefix hick/deobECHO3.nii hick/ECHO3.nii
        3dWarp -deoblique -prefix hick/deobECHO4.nii hick/ECHO4.nii

        if ( -d ./tapping ) then 
            3dWarp -deoblique -prefix tapping/deobECHO1.nii tapping/ECHO1.nii
            3dWarp -deoblique -prefix tapping/deobECHO2.nii tapping/ECHO2.nii
            3dWarp -deoblique -prefix tapping/deobECHO3.nii tapping/ECHO3.nii
            3dWarp -deoblique -prefix tapping/deobECHO4.nii tapping/ECHO4.nii
        endif
    endif
    
    3dWarp -deoblique -prefix $output_dir/anat $output_dir/tmpanat+orig

    # EPI runs for echo 1 (fave_echo = registration driver)
    3dTcat -prefix $output_dir/pb00.$subj.r01.e01.tcat breathhold/deobECHO1.nii
    3dTcat -prefix $output_dir/pb00.$subj.r02.e01.tcat hick/deobECHO1.nii

    # EPI runs for echo 2 (registration follower)
    3dTcat -prefix $output_dir/pb00.$subj.r01.e02.tcat breathhold/deobECHO2.nii
    3dTcat -prefix $output_dir/pb00.$subj.r02.e02.tcat hick/deobECHO2.nii


    # EPI runs for echo 3 (registration follower)
    3dTcat -prefix $output_dir/pb00.$subj.r01.e03.tcat breathhold/deobECHO3.nii
    3dTcat -prefix $output_dir/pb00.$subj.r02.e03.tcat hick/deobECHO3.nii


    # EPI runs for echo 4 (registration follower)
    3dTcat -prefix $output_dir/pb00.$subj.r01.e04.tcat breathhold/deobECHO4.nii
    3dTcat -prefix $output_dir/pb00.$subj.r02.e04.tcat hick/deobECHO4.nii

    if ( -d ./tapping ) then 
        3dTcat -prefix $output_dir/pb00.$subj.r03.e01.tcat tapping/deobECHO1.nii
        3dTcat -prefix $output_dir/pb00.$subj.r03.e02.tcat tapping/deobECHO2.nii
        3dTcat -prefix $output_dir/pb00.$subj.r03.e03.tcat tapping/deobECHO3.nii
        3dTcat -prefix $output_dir/pb00.$subj.r03.e04.tcat tapping/deobECHO4.nii
    endif


    # -------------------------------------------------------
    # enter the results directory (can begin processing data)
    cd $output_dir

    set TR1 = "`3dinfo -nt pb00.$subj.r01.e01.tcat+orig.HEAD`"
    set TR2 = "`3dinfo -nt pb00.$subj.r02.e01.tcat+orig.HEAD`"

    if ( -d ../../tapping ) then 
        set TR3 = "`3dinfo -nt pb00.$subj.r03.e01.tcat+orig.HEAD`"
        set tr_counts=("$TR1" "$TR2" "$TR3")
    else
        set tr_counts=("$TR1" "$TR2")
    endif
    #set TR1end = "`expr $TR1 - 1`"
    # and make note of repetitions (TRs) per run

    # ========================== auto block: outcount ==========================
    # data check: compute outlier fraction for each volume
    touch out.pre_ss_warn.txt
    foreach run ( $runs )
        3dToutcount -automask -fraction -polort 7 -legendre                     \
                    pb00.$subj.r$run.e$fave_echo.tcat+orig > outcount.r$run.1D

        # outliers at TR 0 might suggest pre-steady state TRs
        if ( `1deval -a outcount.r$run.1D"{0}" -expr "step(a-0.4)"` ) then
            echo "** TR #0 outliers: possible pre-steady state TRs in run $run" \
                >> out.pre_ss_warn.txt
        endif
    end

    # catenate outlier counts into a single time series
    cat outcount.r*.1D > outcount_rall.1D

    # get run number and TR index for minimum outlier volume
    set minindex = `3dTstat -argmin -prefix - outcount_rall.1D\'`
    set ovals = ( `1d_tool.py -set_run_lengths $tr_counts                       \
                              -index_to_run_tr $minindex` )
    # save run and TR indices for extraction of vr_base_min_outlier
    set minoutrun = $ovals[1]
    set minouttr  = $ovals[2]
    echo "min outlier: run $minoutrun, TR $minouttr" | tee out.min_outlier.txt

    # ================================ despike =================================
    # apply 3dDespike to each run
    foreach run ( $runs )
        foreach eind ( $echo_list )
            3dDespike -NEW -nomask -prefix rm.pb01.$subj.r$run.e$eind.despike \
                pb00.$subj.r$run.e$eind.tcat+orig
        end
    end

    # ======================== respiratory correction ==========================
    # apply retricor to each run
    foreach eind ( $echo_list )
        mv rm.pb01.$subj.r01.e$eind.despike+orig.BRIK pb01.$subj.r01.e$eind.despike+orig.BRIK
        mv rm.pb01.$subj.r01.e$eind.despike+orig.HEAD pb01.$subj.r01.e$eind.despike+orig.HEAD
    end
    foreach run ( $runsMotReg )
        set FILE = stimuli/respData_r${run}.1D
        if ( -f "$FILE" ) then 
            foreach eind ( $echo_list )
                3dretroicor -prefix pb01.$subj.r$run.e$eind.despike \
                   -resp stimuli/respData_r$run.1D -respphase stimuli/respPhase_r$run.1D \
                   rm.pb01.$subj.r$run.e$eind.despike+orig
            end
        else
            foreach eind ( $echo_list )
                mv rm.pb01.$subj.r$run.e$eind.despike+orig.BRIK pb01.$subj.r$run.e$eind.despike+orig.BRIK
                mv rm.pb01.$subj.r$run.e$eind.despike+orig.HEAD pb01.$subj.r$run.e$eind.despike+orig.HEAD
            end
        endif
    end

    # ================================= tshift =================================
    # time shift data so all slice timing is the same 
    foreach run ( $runs )
        foreach eind ( $echo_list )
            3dTshift -tzero 0 -quintic -prefix pb02.$subj.r$run.e$eind.tshift \
                     pb01.$subj.r$run.e$eind.despike+orig
        end
    end

    # --------------------------------
    # extract volreg registration base
    3dbucket -prefix vr_base_min_outlier                                      \
        pb02.$subj.r$minoutrun.e$fave_echo.tshift+orig"[$minouttr]"

    # ================================= align ==================================
    # a2e: align anatomy to EPI registration base
    # (new anat will be aligned and stripped, anat_al_keep+orig)
    align_epi_anat.py -anat2epi -anat anat+orig      \
           -suffix _al_keep                          \
           -epi vr_base_min_outlier+orig -epi_base 0 \
           -epi_strip 3dSkullStrip                   \
           -giant_move -cmass cmass+a                \
           -volreg off -tshift off

    # ================================== tlrc ==================================
    # warp anatomy to standard space
    @auto_tlrc -base $template -input anat_al_keep+orig -no_ss -init_xform AUTO_CENTER 

    # store forward transformation matrix in a text file
    cat_matvec anat_al_keep+tlrc::WARP_DATA -I > warp.anat.Xat.1D

    # ================================= volreg =================================
    # align each dset to base volume, warp to tlrc space

    # verify that we have a +tlrc warp dataset
    if ( ! -f anat_al_keep+tlrc.HEAD ) then
        echo "** missing +tlrc warp dataset: anat_al_keep+tlrc.HEAD" 
        exit
    endif

    # register and warp
    foreach run ( $runs )
        # register each volume to the base image
        # (registration is driven by $fave_echo)
        3dvolreg -verbose -zpad 1 -base vr_base_min_outlier+orig                \
                 -1Dfile dfile.r$run.1D -prefix rm.epi.volreg.r$run.e$fave_echo \
                 -cubic                                                         \
                 -1Dmatrix_save mat.r$run.vr.aff12.1D                           \
                 pb02.$subj.r$run.e$fave_echo.tshift+orig

        # create an all-1 dataset to mask the extents of the warp
        3dcalc -overwrite -a pb02.$subj.r$run.e$fave_echo.tshift+orig -expr 1   \
               -prefix rm.epi.all1

        # catenate volreg/tlrc xforms
        cat_matvec -ONELINE                                                     \
                   anat_al_keep+tlrc::WARP_DATA -I                              \
                   mat.r$run.vr.aff12.1D > mat.r$run.warp.aff12.1D

        # apply catenated xform: volreg/tlrc
        # (apply warps per echo - warps are fixed, per run)
        foreach eind ( $echo_list )
           3dAllineate -base anat_al_keep+tlrc                                  \
                       -input pb02.$subj.r$run.e$eind.tshift+orig               \
                       -1Dmatrix_apply mat.r$run.warp.aff12.1D                  \
                       -mast_dxyz 3                                             \
                       -prefix rm.epi.nomask.r$run.e$eind
        end

        # warp the all-1 dataset for extents masking 
        3dAllineate -base anat_al_keep+tlrc                                     \
                    -input rm.epi.all1+orig                                     \
                    -1Dmatrix_apply mat.r$run.warp.aff12.1D                     \
                    -mast_dxyz 3 -final NN -quiet                               \
                    -prefix rm.epi.1.r$run

        # make an extents intersection mask of this run
        3dTstat -min -prefix rm.epi.min.r$run rm.epi.1.r$run+tlrc
    end

    # make a single file of registration params
    cat dfile.r*.1D > dfile_rall.1D

    # compute motion magnitude time series: the Euclidean norm
    # (sqrt(sum squares)) of the motion parameter derivatives
    1d_tool.py -infile dfile_rall.1D                                            \
               -set_run_lengths $tr_counts                                         \
               -derivative -collapse_cols euclidean_norm                        \
               -write motion_${subj}_enorm.1D

    # ----------------------------------------
    # create the extents mask: mask_epi_extents+tlrc
    # (this is a mask of voxels that have valid data at every TR)
    3dMean -datum short -prefix rm.epi.mean rm.epi.min.r*.HEAD 
    3dcalc -a rm.epi.mean+tlrc -expr 'step(a-0.999)' -prefix mask_epi_extents

    # and apply the extents mask to the EPI data 
    # (delete any time series with missing data)
    foreach run ( $runs )
        foreach eind ( $echo_list )
            3dcalc -a rm.epi.nomask.r$run.e$eind+tlrc -b mask_epi_extents+tlrc  \
                   -expr 'a*b' -prefix pb03.$subj.r$run.e$eind.volreg
        end
    end

    # warp the volreg base EPI dataset to make a final version
    cat_matvec -ONELINE anat_al_keep+tlrc::WARP_DATA -I > mat.basewarp.aff12.1D

    3dAllineate -base anat_al_keep+tlrc                                         \
                -input vr_base_min_outlier+orig                                 \
                -1Dmatrix_apply mat.basewarp.aff12.1D                           \
                -mast_dxyz 3                                                    \
                -prefix final_epi_vr_base_min_outlier

    # create an anat_final dataset, aligned with stats
    3dcopy anat_al_keep+tlrc anat_final.$subj

    # record final registration costs
    3dAllineate -base final_epi_vr_base_min_outlier+tlrc -allcostX              \
                -input anat_final.$subj+tlrc |& tee out.allcostX.txt

    # -----------------------------------------
    # warp anat follower datasets (affine)

    # catenate all transformations
    cat_matvec -ONELINE                                                         \
               warp.anat.Xat.1D                                                 \
               anat_al_keep_mat.aff12.1D > warp.all.anat.aff12.1D

    3dAllineate -source anat+orig                                               \
                -master anat_final.$subj+tlrc                                   \
                -final wsinc5 -1Dmatrix_apply warp.all.anat.aff12.1D            \
                -prefix anat_w_skull_warped

    # ================================== mask ==================================
    # create 'full_mask' dataset (union mask)
    foreach run ( $runs )
        3dAutomask -prefix rm.mask_r$run pb03.$subj.r$run.e$fave_echo.volreg+tlrc
    end

    # create union of inputs, output type is byte
    3dmask_tool -inputs rm.mask_r*+tlrc.HEAD -union -prefix full_mask.$subj

    # ---- create subject anatomy mask, mask_anat.$subj+tlrc ----
    #      (resampled from tlrc anat)
    3dresample -master full_mask.$subj+tlrc -input anat_al_keep+tlrc      \
               -prefix rm.resam.anat

    # convert to binary anat mask; fill gaps and holes
    3dmask_tool -dilate_input 5 -5 -fill_holes -input rm.resam.anat+tlrc  \
                -prefix mask_anat.$subj

    # compute tighter EPI mask by intersecting with anat mask
    3dmask_tool -input full_mask.$subj+tlrc mask_anat.$subj+tlrc          \
                -inter -prefix mask_epi_anat.$subj

    # compute overlaps between anat and EPI masks
    3dABoverlap -no_automask full_mask.$subj+tlrc mask_anat.$subj+tlrc    \
                |& tee out.mask_ae_overlap.txt

    # note Dice coefficient of masks, as well
    3ddot -dodice full_mask.$subj+tlrc mask_anat.$subj+tlrc               \
          |& tee out.mask_ae_dice.txt

    # ---- create group anatomy mask, mask_group+tlrc ----
    #      (resampled from tlrc base anat, MNI152_T1_2009c+tlrc)
    3dresample -master full_mask.$subj+tlrc -prefix ./rm.resam.group      \
               -input $template

    # convert to binary group mask; fill gaps and holes
    3dmask_tool -dilate_input 5 -5 -fill_holes -input rm.resam.group+tlrc \
                -prefix mask_group

    # note Dice coefficient of anat and template masks
    3ddot -dodice mask_anat.$subj+tlrc mask_group+tlrc                    \
          |& tee out.mask_at_dice.txt

    # ---- segment anatomy into classes CSF/GM/WM ----
    3dSeg -anat anat_final.$subj+tlrc -mask AUTO -classes 'CSF ; GM ; WM'

    # copy resulting Classes dataset to current directory
    3dcopy Segsy/Classes+tlrc .

    # make individual ROI masks for regression (CSF GM WM and CSFe GMe WMe)
    foreach class ( CSF GM WM )
       # unitize and resample individual class mask from composite
       3dmask_tool -input Segsy/Classes+tlrc"<$class>"                    \
                   -prefix rm.mask_${class}
       3dresample -master pb03.$subj.r01.e$eind.volreg+tlrc -rmode NN     \
                  -input rm.mask_${class}+tlrc -prefix mask_${class}_resam
       # also, generate eroded masks
       3dmask_tool -input Segsy/Classes+tlrc"<$class>" -dilate_input -1   \
                   -prefix rm.mask_${class}e
       3dresample -master pb03.$subj.r01.e$eind.volreg+tlrc -rmode NN     \
                  -input rm.mask_${class}e+tlrc -prefix mask_${class}e_resam
    end

    # ================================ combine =================================
    # combine multi-echo data per run, using m_tedana_OC (tedana from MEICA group)

    # ----- method m_tedana_OC : generate tedana (MEICA group) results  -----
    # (get MEICA tedana OC result, desc-optcomDenoised_bold.nii.gz)

    # first run tedana commands, to see if they all succeed
    foreach run ( $runs )
       tedana -d pb03.$subj.r$run.e*.volreg+tlrc.HEAD \
              -e $echo_times                          \
              --mask mask_epi_anat.$subj+tlrc.HEAD    \
              --out-dir tedana_r$run
    end

    # now get the tedana results
    foreach run ( $runs )
       # copy result back here
       3dcopy tedana_r$run/desc-optcomDenoised_bold.nii.gz pb04.$subj.r$run.combine+tlrc

       # for some reason, tedana combination brings the data of orig status to TLRC
       3drefit -space tlrc pb04.$subj.r$run.combine+tlrc
    end

    # ================================== Perfusion Weights datasets creation ==================================
    # 4 different datasets : filtering at 0.009 Hz, Suround Substraction, MEICA, and meaning
    # blur each volume of each run
    foreach run ( $runs )
        foreach e (1 2 3 4)
    # Running Surround Substraction
            3dcalc                                    \
                -a pb03.$subj.r$run.e0$e.volreg+tlrc  \
                -b 'a[0,0,0,1]*d'                     \
                -c 'a[0,0,0,-1]*d'                    \
                -d mask_epi_anat.${subj}+tlrc              \
                -expr '(a*d-0.5*(b+c))*(-1)**(l+1)'   \
                -prefix pb04.$subj.r$run.e0$e.SuroundSubstr
    # Low pass filtering for MEICA algorithme.
            3dTproject -polort -1 -input pb03.$subj.r$run.e0$e.volreg+tlrc -prefix BOLD_ECHO${e}.r$run.nii -stopband 0.09 9999 -mask mask_epi_anat.${subj}+tlrc.HEAD
        end
        3dAFNItoNIFTI mask_epi_anat.${subj}+tlrc.HEAD
        
    # MEICA
         if (! -d ./MEICAtoBEerased) mkdir ./MEICAtoBEerased
        # isolating BOLd and artefacts components
        tedana -d BOLD_ECHO*.r$run.nii -e 9.1 25 39.6 54.3 --fittype loglin --out-dir ./MEICAtoBEerased --mask mask_epi_anat.${subj}+tlrc.HEAD --seed 69
        # extracting PW data with MEICA technique
        3dTproject -input pb03.$subj.r$run.e01.volreg+tlrc -prefix rm.MEICA_PW_ECHO1.r$run.nii -dsort ./MEICAtoBEerased/desc-optcomRejected_bold.nii* -dsort ./MEICAtoBEerased/desc-optcomAccepted_bold.nii* -mask mask_epi_anat.${subj}+tlrc.HEAD
        3dTproject -input rm.MEICA_PW_ECHO1.r$run.nii -prefix rm.highPassedEcho1.r$run -polort -1 -stopband 0 0.09
        1deval -expr 'cos(PI*(t+1))' -num $tr_counts[$run] > cos.1D
        3dcalc -a rm.highPassedEcho1.r$run+tlrc.BRIK -b cos.1D -prefix pb04.$subj.r$run.e01.MEICA -expr 'a*b'

    # MEAN dataset
         foreach e (1 2 3 4)
            3dAFNItoNIFTI -prefix ECHO$e.VolregTemp.nii pb03.$subj.r$run.e0$e.volreg+tlrc
            3dcalc -a mask_epi_anat.${subj}+tlrc.HEAD -b ECHO$e.VolregTemp.nii -expr "a*b" -prefix SSECHO$e.VolregTemp.nii
            3dTproject -input SSECHO$e.VolregTemp.nii -prefix highPassed.r$run.e0$e.nii -polort -1 -stopband 0 0.09
            rm *ECHO$e.VolregTemp.nii
            1deval -expr 'cos(PI*(t+1))' -num $tr_counts[$run] > cos.1D
            3dcalc -a highPassed.r$run.e0$e.nii -b cos.1D -prefix pb04.$subj.r$run.e0$e.Filt009 -expr 'a*b' #verified through matlab
        end
        3dcalc -a pb04.$subj.r$run.e01.Filt009+tlrc                              \
               -b pb04.$subj.r$run.e02.Filt009+tlrc                              \
               -c pb04.$subj.r$run.e03.Filt009+tlrc                              \
               -d pb04.$subj.r$run.e04.Filt009+tlrc                              \
               -expr '(a+b+c+d)/4' -prefix pb04.$subj.r$run.eMEAN.Filt009
        rm -R ./MEICAtoBEerased
    end
    #rm rm.*
    rm BOLD_ECHO*


    # ================================== blur ==================================
    # blur each volume of each run
    foreach run ( $runs )
        3dmerge -1blur_fwhm 4.5 -doall -prefix rm.pb05.$subj.r$run.blur  \
                pb04.$subj.r$run.combine+tlrc

        3dmerge -1blur_fwhm 4.5 -doall -prefix rm.pb05.$subj.r$run.e01.PW.blur  \
                pb04.$subj.r$run.e01.Filt009+tlrc

        3dmerge -1blur_fwhm 4.5 -doall -prefix rm.pb05.$subj.r$run.eMEAN.blur  \
                pb04.$subj.r$run.eMEAN.Filt009+tlrc

        3dmerge -1blur_fwhm 4.5 -doall -prefix rm.pb05.$subj.r$run.e01.SurSub.blur  \
                pb04.$subj.r$run.e01.SuroundSubstr+tlrc

        3dmerge -1blur_fwhm 4.5 -doall -prefix rm.pb05.$subj.r$run.e01.MEICA.blur  \
                pb04.$subj.r$run.e01.MEICA+tlrc

        # copying 2nd echo as BOLD signal
        3dmerge -1blur_fwhm 4.5 -doall -prefix rm.pb05.$subj.r$run.e02.blur  \
                pb03.$subj.r$run.e02.volreg+tlrc.HEAD

        # and apply extents mask, since no scale block
        3dcalc -a rm.pb05.$subj.r$run.blur+tlrc -b mask_epi_anat.${subj}+tlrc.HEAD \
               -expr 'a*b' -prefix pb05.$subj.r$run.blur
        3dcalc -a rm.pb05.$subj.r$run.e01.PW.blur+tlrc -b mask_epi_anat.${subj}+tlrc.HEAD \
               -expr 'a*b' -prefix pb05.$subj.r$run.e01.PW.blur
        3dcalc -a rm.pb05.$subj.r$run.eMEAN.blur+tlrc -b mask_epi_anat.${subj}+tlrc.HEAD \
               -expr 'a*b' -prefix pb05.$subj.r$run.eMEAN.blur
        3dcalc -a rm.pb05.$subj.r$run.e01.SurSub.blur+tlrc -b mask_epi_anat.${subj}+tlrc.HEAD \
               -expr 'a*b' -prefix pb05.$subj.r$run.e01.SurSub.blur
        3dcalc -a rm.pb05.$subj.r$run.e01.MEICA.blur+tlrc -b mask_epi_anat.${subj}+tlrc.HEAD \
               -expr 'a*b' -prefix pb05.$subj.r$run.e01.MEICA.blur
        3dcalc -a rm.pb05.$subj.r$run.e02.blur+tlrc -b mask_epi_anat.${subj}+tlrc.HEAD \
               -expr 'a*b' -prefix pb05.$subj.r$run.e02.blur
    end

    mkdir -p "$dataFolder/$subj/Analysis/Images"
    @snapshot_volreg                           \
        "$dataFolder/$subj/Analysis/$output_directory/anat_final.${subj}+tlrc.BRIK"                    \
        "$dataFolder/$subj/Analysis/$output_directory/pb04.${subj}.r01.combine+tlrc"  \
        "$dataFolder/$subj/Analysis/Images/alignment_anat_to_epi_${subj}+tlrc"  

    @snapshot_volreg                            \
        "$dataFolder/$subj/Analysis/$output_directory/anat_final.${subj}+tlrc.BRIK"                     \
        $template   \
        "$dataFolder/$subj/Analysis/Images/alignment_anat_to_template_${subj}+tlrc" 

    # remove temporary files
    \rm -fr rm.* Segsy

    cd $dataFolder/$subj/Analysis/$output_directory
    mkdir ../temp$output_directory
    foreach run ( $runs )
        cp    motion_${subj}_enorm.1D ../temp${output_directory}/motion_${subj}_censor.1D
        cp    pb04.$subj.r01.combine+tlrc.HEAD ../temp${output_directory}/pb02.$subj.r01.volreg+tlrc.HEAD
        cp    pb04.$subj.r01.combine+tlrc.BRIK ../temp${output_directory}/pb02.$subj.r01.volreg+tlrc.BRIK

        cp    pb05.$subj.r$run.e01.MEICA.blur+tlrc.* \
              pb05.$subj.r$run.e01.SurSub.blur+tlrc.* \
              pb05.$subj.r$run.eMEAN.blur+tlrc.* \
              pb05.$subj.r$run.e01.PW.blur+tlrc.* \
              pb05.$subj.r$run.e02.blur+tlrc.* \
              pb05.$subj.r$run.blur+tlrc.* \
              pb04.$subj.r01.combine+tlrc.* \
              anat_final.${subj}+tlrc.* \
              anat+orig.* \
              anat_al_keep+orig* \
              anat_final.${subj}+tlrc.HEAD \
              dfile* \
              *mask* \
              *warp* \
              *.1D \
              *.jpg \
              *.txt \
              pb00.${subj}.r01.e01.tcat+orig.HEAD \
              outcount_rall.1D \
              motion_${subj}_enorm.1D \
              dfile_rall.1D \
              ../temp$output_directory
    end

    rm $dataFolder/$subj/Analysis/$output_directory/*.*
    cp ../temp$output_directory/* ../$output_directory
    rm -R ../temp$output_directory

    cd $home
end
# ========================== auto block: finalize ==========================

# if the basic subject review script is here, run it
# (want this to be the last text output)
if ( -e @ss_review_basic ) then
    ./@ss_review_basic |& tee out.ss_review.$subj.txt

    # generate html ss review pages
    # (akin to static images from running @ss_review_driver)
    apqc_make_tcsh.py -review_style basic -subj_dir . \
        -uvar_json out.ss_review_uvars.json
    tcsh @ss_review_html |& tee out.review_html
    apqc_make_html.py -qc_dir QC_$subj

    echo "\nconsider running: \n\n    afni_open -b $subj.results/QC_$subj/index.html\n"
endif

# return to parent directory (just in case...)
cd ..

echo "execution finished: `date`"


# ==========================================================================
# script generated by the command:
#
# afni_proc.py -subj_id ${subj} -blocks despike tshift align tlrc volreg mask                                                                                \
#     combine blur regress -copy_anat anat.nii.gz -echo_times 9.1 25 39.6                                                                                    \
#     54.3 -blur_size 4.5 -reg_echo 1 -dsets_me_run hick/ECHO1.nii.gz                                                                                        \
#     hick/ECHO2.nii.gz hick/ECHO3.nii.gz hick/ECHO4.nii.gz                                                                                                  \
#     -regress_motion_per_run -dsets_me_run breathhold/ECHO1.nii.gz                                                                                          \
#     breathhold/ECHO2.nii.gz breathhold/ECHO3.nii.gz breathhold/ECHO4.nii.gz                                                                                \
#     -tlrc_base MNI152_T1_2009c+tlrc -tcat_remove_first_trs 10                                                                                              \
#     -volreg_align_to MIN_OUTLIER -volreg_tlrc_warp -regress_reml_exec                                                                                      \
#     -regress_compute_tsnr yes -align_epi_strip_method 3dSkullStrip                                                                                         \
#     -align_opts_aea -giant_move -cmass cmass+a -combine_method m_tedana_OC                                                                                 \
#     -mask_segment_anat yes -mask_segment_erode yes -regress_stim_times                                                                                     \
#     XXX/quantitativ_fMRI/data/regressors/BH_regressor_2runs_${subj}_-10TR.1D                    \
#     XXX/quantitativ_fMRI/data/regressors/BH_regressor_2runs_${subj}_-11TR.1D                    \
#     XXX/quantitativ_fMRI/data/regressors/BH_regressor_2runs_${subj}_-12TR.1D                    \
#     XXX/quantitativ_fMRI/data/regressors/BH_regressor_2runs_${subj}_-2TR.1D                     \
#     XXX/quantitativ_fMRI/data/regressors/BH_regressor_2runs_${subj}_-3TR.1D                     \
#     XXX/quantitativ_fMRI/data/regressors/BH_regressor_2runs_${subj}_-4TR.1D                     \
#     XXX/quantitativ_fMRI/data/regressors/BH_regressor_2runs_${subj}_-5TR.1D                     \
#     XXX/quantitativ_fMRI/data/regressors/BH_regressor_2runs_${subj}_-6TR.1D                     \
#     XXX/quantitativ_fMRI/data/regressors/BH_regressor_2runs_${subj}_-7TR.1D                     \
#     XXX/quantitativ_fMRI/data/regressors/BH_regressor_2runs_${subj}_-8TR.1D                     \
#     XXX/quantitativ_fMRI/data/regressors/BH_regressor_2runs_${subj}_-9TR.1D                     \
#     XXX/quantitativ_fMRI/data/regressors/thirdScanHickregressor_cond1_ofst10_2runs_${subj}.1D   \
#     XXX/quantitativ_fMRI/data/regressors/thirdScanHickregressor_cond2_ofst10_2runs_${subj}.1D   \
#     XXX/quantitativ_fMRI/data/regressors/thirdScanHickregressor_cond4_ofst10_2runs_${subj}.1D   \
#     -regress_stim_labels 0TR m1TR m2TR 8TR 7TR 6TR 5TR 4TR 3TR 2TR 1TR                                                                                     \
#     cond1 cond2 cond3 -mask_epi_anat yes
